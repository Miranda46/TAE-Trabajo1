# -*- coding: utf-8 -*-
"""TAE-Trabajo1.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1MOJCxfNU9etlhftKaUZWLXtTRgEcsCpV

Se importan los datos y algunas librerías
"""

import io
import pandas as pd
df = pd.read_csv("CollegeScorecard.csv")
nan_value = float("NaN") 
df.replace("", nan_value, inplace=True)## se reemplaza todos los datos vacios por NaN
##df.replace(0, nan_value, inplace=True)

df.dropna(how='all', axis=1, inplace=True) ## se eliminan todas las columnas vacias

df.shape## pasamos de tener 1725 columnas a 551

pd.options.display.max_columns = None
#df.columns = pd.MultiIndex.from_arrays([pd.RangeIndex(len(df.columns)), df.columns])
df

"""Se importa el diccionario de los datos para analizar qué variables se pueden descartar."""

import io
import pandas as pd
import numpy as np

dfFinal = df.filter(["UNITID", "INSTNM", "LATITUDE", "LONGITUDE",  "DEP_INC_AVG", "IND_INC_AVG", "GRAD_DEBT_MDN", "CONTROL"])
dfFinal.replace(to_replace="PrivacySuppressed", value= np.NaN, inplace = True)
dfFinal
dfFinal["DEP_INC_AVG"] = dfFinal["DEP_INC_AVG"].astype(float)
dfFinal["IND_INC_AVG"] = dfFinal["IND_INC_AVG"].astype(float)
dfFinal["GRAD_DEBT_MDN"] = dfFinal["GRAD_DEBT_MDN"].astype(float)
dfFinal.dtypes
dfFinal.describe()
dfFinal = dfFinal.dropna()
dfUbicacion = dfFinal.drop(axis = 1, columns=["DEP_INC_AVG", "IND_INC_AVG", "GRAD_DEBT_MDN", "CONTROL"])
dfUbicacion
dfFinal = dfFinal.drop(axis = 1, columns=["INSTNM", "LATITUDE", "LONGITUDE"])
dfFinal.set_index("UNITID", inplace = True)
from sklearn import preprocessing
dfFinalNorm = dfFinal.copy()
dfFinalNorm[["DEP_INC_AVG", "IND_INC_AVG", "GRAD_DEBT_MDN"]] = preprocessing.MinMaxScaler().fit_transform(dfFinal[["DEP_INC_AVG", "IND_INC_AVG", "GRAD_DEBT_MDN"]])
dfFinalNorm

# Commented out IPython magic to ensure Python compatibility.
from tabulate import tabulate 
from sklearn.cluster import KMeans
from sklearn.metrics import silhouette_score
from sklearn.metrics import pairwise_distances_argmin_min
import scipy.cluster.hierarchy as sch
from scipy.spatial.distance import squareform
from scipy.spatial import distance_matrix

modelo = KMeans()
dfFinal_3D = np.array(dfFinalNorm[["DEP_INC_AVG", "IND_INC_AVG", "GRAD_DEBT_MDN"]])
kmeansModelo = KMeans(n_clusters=3, max_iter=1000).fit(dfFinal_3D)
kmeansModeloLabels = kmeansModelo.labels_
kmeansModeloCentroides = kmeansModelo.cluster_centers_
kmeansModeloCentroides
dfFinal['cluster'] = kmeansModeloLabels
dfFinalNorm['cluster'] = kmeansModeloLabels
dfFinal.drop('cluster', axis=1).describe()
cluster_0 = dfFinal[dfFinal['cluster'] == 0]
cluster_0.drop('cluster', axis=1).describe()
cluster_1 = dfFinal[dfFinal['cluster'] == 1]
cluster_1.drop('cluster', axis=1).describe()
cluster_2 = dfFinal[dfFinal['cluster'] == 2]
cluster_2.drop('cluster', axis=1).describe()
dfFinal.groupby(["cluster"]).describe()
#array con los datos que se trabaja
df_array = np.array(dfFinalNorm[["DEP_INC_AVG", "IND_INC_AVG", "GRAD_DEBT_MDN"]])
#se genera modelo de Kmeans para el array anterior
kmeans_model = KMeans(n_clusters=3).fit(df_array)
labels = kmeans_model.labels_
#Se hallan los centroides para hacer la función Scatter. 
centroides = kmeans_model.cluster_centers_
